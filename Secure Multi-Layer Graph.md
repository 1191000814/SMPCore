### 摘要

多层图中的稠密子图挖掘是图计算的一项基本任务, 已经在社交网络社区检测、图索引构建、DNA 中的监管主题发现、商品推荐等领域进行了广泛应用.但是在现实中, 多层图中的每一层可能属于不同的数据所有者, 不同的层中存在**数据隔离**, 数据所有者之间不能共享原始数据, 一个有效的解决方法是安全多方计算(SMPC), 安全多方计算使用混淆电路, 秘密共享等隐私原语保护了每一方的原始数据。我们是第一个将安全多方计算应用于多层图(ML graph)稠密子图挖掘领域, 我们提出了MPC-Firmcore算法, 针对具体的算法Firmcore[1]进行了隐私保护和算法优化, 以较小的开销实现多个数据提供者之间的安全计算. 并在多个真实和合成的数据集中进行广泛的实验, 证明了该算法的高效性和安全性.

关键字: 多层图 稠密子图 安全多方计算

#### 1 介绍

> 宽泛地概括各类问题和技术, 主要介绍问题的motivation和application, 

随着大数据时代的发展, 数据隐私变得越来越重要, 许多机构和公司将数据使用分布式存储, 云存储等方式存储数据, 但是在数据使用时的隐私泄露问题也变得很严峻. 很多数据都可以使用多层图进行表示, 多层图上的信息挖掘工作已经取得了很多进展, 但是以前的工作并都是将整个多层图看成一个数据库整体, 并没有考虑隐私保护问题. 但是在现实中, 可能多层图中的每一层都属于不同的数据所有者, 举几个例子说明:

- 在中国, 存在很多社交网络app, 使用某个app的用户都需要一个手机号注册, 且每个手机号只能注册一个账号.我们可以将整个社交网络看成一个多层图, 每个用户是图中的一个节点, 每个社交网络app是多层图中的一层. 因为不同的社交软件属于不同的公司, 他们不能与其他的公司共享原始数据, 但是有时候多个公司之间想通过共有的数据进行一些用户信息的计算和分析.
- 供应链也可以被视为一个多层图，其中每一层指的是一个过程, 如生产过程, 制造过程, 销售过程; 制造商、分销商、零售商、供应商和物流提供商等可以被看成一个节点，多层图的边表示以及它们之间的交易、运输和合同关系。每个过程可能被不同的部门管理，供应链中的各方需要在不泄露敏感信息的情况下, 合作优化库存管理、需求预测和风险评估.

稠密子图发现(DSD)[1]问题的目的是找出多层图中的稠密结构, DSD是多层图领域的一个经典问题, 有着十分广泛的应用. 它可以用于分析社交网络中的人际关系, 生物信息学中的物质结构, 以及网络安全中的潜在攻击等. 我们的工作在Firmcore算法的基础上进行改进, 因为Firmcore算法本身比较简单, 其次各层可以较大程度独立地进行数据获取和计算, 便于实现安全多方计算.

隐私计算已经在很多领域进行了广泛和深入的探索, 如应用于KNN问题[2], 室内定位服务问题和联邦学习等, 但是并没有在多层图领域进行系统的研究, 这篇论文对该领域的内容进行了一个初步的探索, 我们使用安全多方计算来实现多层图Firmcore算法的隐私保护版本SMPC-Firmcore, 并针对算法做了多种优化, 以提高算法的运行效率. 安全多方计算的概念最早由Yehoshua Afek和Michael O. Rabin在1983年提出。随后，Oded Goldreich、Silvio Micali和Avi Wigderson在1987年提出了一个更通用的解决方案，奠定了现代SMC的基础。近年来，随着云计算和大数据的兴起，SMC在数据隐私保护、金融服务、医疗健康等领域的应用越来越广泛。

在本文中, 我们提出了SMPC-Firmcore, 使用安全多方计算, 在联邦隐私环境下安全地找出多层图的稠密子图. 我们在原算法的基础上, 提出三种安全的算法, 并在不同的数据集上进行了对比. 总之, 我们的主要贡献为:

1. 首次提出了将安全多方计算应用于多层图计算领域
2. 实现了隐私安全版本的Firmcore算法
3. 对安全算法进行了性能优化, 并在多个数据集上进行广泛的实验得到结果并验证.

### 2 问题背景

> 较为详细地介绍每一项技术的内容

#### 2.1 多层图上的稠密子图发现

DSD问题需要我们找出图中的稠密子图, 这主要包括几种问题: (1) 什么样的子图能称之为稠密? (2) 如何找到这样的子图 ? (3) 整个算法的时间复杂度. 以前人们也提出了很多用来解决单层图上该问题的算法, 较简单的如k-core, k-truss, k-clique和k-plex等, 近年来也有新的针对于多层图上该算法的改进如Firmcore, FirmTruss(列举...)等等. 

`Firmcore`算法是Farnoosh Hashemi等提出的一个解决DSD问题的一个简单有效的方法, 属于core decomposition方法类别.他将每个图的最大的k-core定义为一个最稠密子图, 在单层图中, k-core的每个顶点都有至少k个邻居; 在多层图上, 我们不强制要求节点在每层上都有k个邻居, 而是引入一个松弛度$\lambda$, 定义k-core的每个顶点在至少$\lambda$层上都有至少k个邻居; 该算法使用较少的时间就能找出多层图中的稠密结构. 在本文中, 我们只考虑无向图的情况.

我们使用以前工作中ML图的定义. 我们令$G = (V, E, L)$ 表示一个无向ML图，其中 $V$ 是节点集，$L$ 是层集，$E ⊆ V ×V × L$ 是边集。层 $ℓ ∈ L$ 中节点 $v ∈ V$ 的邻居集合表示为 $N_ℓ(v)$，层 $ℓ$ 中 $v$ 的度数为 $deg_ℓ(v)$ = $|N_ℓ(v)|$.

`Firmcore`算法的主要过程如算法1所示. 首先计算每个节点i中第$\lambda$大的度, 写入数组$I[i]$, 数组$B[k]$记录第$\lambda$大的度为k的所有节点id. 然后每次迭代地删除一个B[k]中的节点 which k是最小的值 which B[k]还不为空.删除一个节点v之后, 更新节点v的的每个邻居u的度, 如果u的度更新之后的值为I[u]-1, 那么u的第$\lambda$大的度的值可能需要更新; 更新所有需要更新I[u]的u值.将每个在key of B为k时删除的节点v记为$core_\lambda(v)$, 说明节点v在多层图ML, 松弛度为$\lambda$的k-core中.

<img src="./assets/image-20240713204506459.png" alt="image-20240713204506459" style="zoom:50%;" />

#### 2.2 安全多方计算

安全多方计算(SMPC)是一种先进的密码学范式，旨在实现数据的隐私保护与联合计算。在SMPC框架下，不存在一个可靠的代理, 多个参与方可以安全地进行协同计算，而无需泄露自己的私有输入数据。这种技术的核心是确保即使在存在恶意参与者的情况下，也能保护数据的安全性和完整性。安全多方计算已经有很多的实现方法, 其核心思想是将计算任务分解为多个部分，每个部分由不同的参与方执行。通过一系列的加密和解密操作，确保每个参与方只能获得最终的计算结果，而无法得知其他参与方的具体输入数据。常见的技术包括但不限于： (1) 秘密共享：将一个秘密分割成多个份额，每个份额由不同的参与方持有，只有当足够多的份额被组合时，才能恢复出原始秘密。 (2) 同态加密：允许在加密数据上直接进行计算，计算结果在解密后与在原始数据上进行相同计算的结果相同。(2) 零知识证明：允许一方证明某个陈述是正确的，而无需提供任何除了正确性之外的信息。

安全多方计算中的每一方数据库被视为一个数据孤岛, 即其不能与其他任何数据库共享原始数据, 发送数据之前必须要将数据进行加密处理, 每一方只能使用oblivious算法进行加密数据的计算, oblivious算法是和输入数据本身无关的计算, 不能通过算法的执行过程推导出输入数据的特征. 比如oblivious的Bitonic mergesort算法; 另外, 从数组中寻找一个元素的索引时, 必须遍历整个数组, 因为不能进行计算的一方察觉元素所在索引的真实值.

> Bitonic mergesort的原理图

<img src="./assets/The-CAS-network-for-an-8-input-bitonic-sorting-17_W640.jpg" alt="The-CAS-network-for-an-8-input-bitonic-sorting-17_W640" style="zoom:67%;" />

我们使用框架MPyC[]来实现安全多方计算, 其底层原理为秘密共享, 支持多种oblivious算法如排序, bool判断等.

#### 2.3 Different Oblivious

> 等会再看要不要写这一段

### 3 问题定义

#### 3.1 ML Graph in SMPC

![image-20240716142416271](./assets/image-20240716142416271.png)

一共有m个数据提供者$P=\{P_1, P_2, ...P_m\}$, 每一个数据提供者$P_i$都有一个单层图数据集$G_l$, 各方的图两两之间都是同态的, 换句话说, 所有的单层图都是一个2.1中介绍的m层的多层图中的一层, 任何$P_l$都不知道任何数据库$G_{j}$ where $i ≠ j$ 的任何信息. 给定一个参数$\lambda$, 我们要求使用安全多方计算, 由每一方将各自的数据广播到其他数据提供者, 每一方通过获取的数据在自己本地进行安全的Firmcore decomposition计算, 得到最终的结果, 即每个节点$v$的$core_\lambda(v)$. 各方的原始数据不应该被泄露, 且各方数据获取的数据满足$(\epsilon, \delta)-dp$差分隐私.表1总结了本文中常用的符号.

| 符号                | 描述                                                  |
| ------------------- | ----------------------------------------------------- |
| $P_l$               | 数据提供者                                            |
| $G_l$               | 数据提供者拥有的单层图(或者说多层图的一层)            |
| $v_i$               | 图中id为$i$的一个节点                                 |
| $V$                 | 图的节点集合                                          |
| $E_l$               | 多层图第$l$层的边集合                                 |
| $m$                 | 数据提供者的数量                                      |
| $λ$                 | Firmcore算法中松弛量参数                              |
| $I$                 | 每个顶点第$\lambda$大的度的数组                       |
| $I_i$               | 顶点$v_i$的第$\lambda$大的度                          |
| $B_k$               | all nodes $v_i$ where $I_i = k$                       |
| $N_l(v_i)$          | 节点$v$在第$l$层的邻居集合                            |
| $core_\lambda(v_i)$ | 节点$v$在松弛变量为$\lambda$时包含在k-core中(k值最大) |

安全模型: 我们使用的安全模型为semi-honest adversary模型, 在SMPC中, 各方之间不存在共谋, 且遵守相关安全协议, 但是每一方数据提供者都是诚实且好奇的, 他们会通过获取的数据来推测其他各方的敏感数据.

效率要求: 算法应该在较短的时间内完成计算, 时间主要包括各方的通信时间和加密数据的计算时间, 因为我们可能需要处理大规模图数据的计算, 所以长时间的延迟的低效算法没有实际意义.我们主要关心的时间延迟在于oblivious算法, 它是整个算法过程中最主要的成本开销.

#### 3.2 主要挑战

在多层图上进行安全多方计算的主要挑战是隐私和计算效率的保证, 以前的隐私计算通常建立较为简单的问题比如KNN, PIR, Private Union等等, 而在图上的计算问题本身较为复杂, 这对能否同时保证安全和效率有较大的困难. 在隐私计算中使用的是和输入数据无关oblivious算法, 这和明文算法有较大的区别, 所以需要重新构造算法过程, 并从不同的角度优化算法.

### 4 SMPC-Firmcore算法

#### 4.1 Baseline

传统的安全多方计算一般要求所有的数据都在加密状态下传输和计算, 但是由于加密之后的一次数据计算涉及到很多次比特位计算, 这样的算法效率太低, 尤其是在多层图节点很多的情况下. 所以我们在算法中允许泄露一部分中间结果, 我们的目的是使用一部分明文计算, 极大地提升算法的执行效率, 但是又尽可能少地泄露各方的数据.我们将2.1中介绍的算法实现为安全多方计算版本.

我们假设$n$为每层图顶点数量$|V|$顶点首先, 每一方拥有多层图中的一层, 每一方在本地计算并维护着自己这层每个节点的度列表$D_{n}=\{d^{(1)}, d^{(2)}, ... d^{(n)}\}$. 每次delete操作中, 各方将自己的$d$通过加密形式发送到其他方, 这样每一方都获取一个临时的度矩阵$D_{m×n}=\{D_n^{(1)}, D_n^{(2)},...D_n^{(m)}\}$, 计算**明文数组**$I$ (line 2)为每个节点在所有层中第$\lambda$大的度,  并计算明文的$B$, 这样每一方都维护一个相同的明文$I$和$B$, 但是不知道每一方的节点准确的度值. 然后每次迭代时, 各方在本地将$I$同一个度为$k$的节点删除(line 6), 更新本地的度列表$D_n$, 并更新$I$和$B$中可能需要更新的节点 (line 11-16).

我们称每一次获取节点并将其删除的操作称为`delete`, 而将$k=k_i$时所有的`delete`操作称为一次`Iteration`.

但是我们发现这样泄露的信息过多, 因为每一方获取明文的$I$值后便会便可以根据自己的节点的度, 推测其他方图的分布信息.我们发现我们在第$k$轮迭代时, 并不需要$I$值大于$k$的节点的任何信息, 所以我们在获取明文$I$之前, 使用oblivious计算将$I$中值大于$k$的修改为padding value, 小于$k$的修改为$k$, 这样每一方获取的明文$I$只包含值为$k$并且马上将要在第$k$轮被删除的节点, 我们获取的最终明文结果中也包含了这个信息. 所以即使没有在全过程使用加密计算, 每一方获取的额外信息仅仅是同一次迭代中不同节点被删除的顺序.

> 算法1伪代码

baseline算法完全是按照集中式Firmcore中的算法步骤进行的, 需要逐个删除所有的节点, 每次删除一个节点, 最多需要更新其所有邻居的度和I值, 其复杂度约为$O(V^2)$, 当节点数很多时, 效率会很低.

#### 4.2 算法的改进

改进的算法使用一种批量删除节点的方法, 减少delete的总次数, 从而降低时间复杂度. 我们的核心思想是每次delete不是只删除一个节点, 而是删除所有$I$值为$k$的节点, 再在各方更新各自的度列表$d^{(i)}$, 并传递给其他方, 重新计算整个数组$I$. 直到I中的值全部大于$k$, 开始第$k+1$次迭代. 改进的算法无需维护全局数组$I$, 因为每次迭代都会重新计算$I$. 算法2的时间复杂度为$O(\alpha V)$, 其中$\alpha$为需要delete的次数, 一般来说$\alpha$远小于$V$, 取决于图的密度.

在没有隐私安全保护的算法中算法2的效率显然低于会低于算法1, 因为每次重新计算一次数组$I$的开销远大于多次修改少量节点的$I$值. 但是在加密计算中, 由于修改操作是在加密数组中进行, 所以也需要较大的开销, 而计算$I$值可以使用效率较高的oblivious归并排序算法, 使得算法2的优势大大提升.

> 图: 在无隐私安全计算中的算法1和算法2时间对比

和算法1一样, 算法2在获取明文的$I$之前, 也使用oblivious计算将$I$中值大于$k$的修改为padding value, 小于$k$的修改为$k$. 不过算法2进一步减少了额外的信息泄露, 因为批量的节点删除会使得用户不知道每个节点的删除顺序.

>  算法2伪代码

算法2也有不足之处, 因为算法2虽然delete的次数较少, 但是每次delete的开销较大. 在同一次迭代中, 随着删除次数的增加, 删除的节点数量将会越来越少. 当每次迭代即将结束时, 每次delete仅仅能删除很少的节点, 但是每次delete仍要重新计算全局节点的I值, 这将造成很大的不必要开销. 

我们综合算法1和算法2, 提出算法3, 其核心思想是, 每次迭代开始时, 先使用算法2的删除方式, 当每次迭代到最后$\beta$个节点时, 使用算法1的删除方式. 因为当节点的I值为k的节点比较多时, 批量删除时每个顶点所需的平均时间较少, 而当节点为I值的节点较少时, 逐个删除时每个顶点较少.$\beta$的值和图的顶点数和密度有关系, 较好的$\beta$值使得算法3的效率往往优于算法2.

算法3在不同条件下使用算法1或者算法2的删除操作, 所以其泄露的信息也是部分节点被删除的顺序, 额外泄露的信息量多于算法1, 但是少于算法2.

> 数据可视化图: 每次迭代中每次delete中删除的节点个数

> 算法3的伪代码

#### 4.3 算法分析

效率和安全的平衡: 我们并没有完全保证各方数据的安全性, 因为将每个步骤都进行oblivious计算会使得计算成本开销极大地增大.在我们的算法中, 每一方在每次delete之后都将获取明文的I值, 所以每一方在每一次delete中都会不可避免地获取一些除最终结果之外的额外信息. 但是我们已经极大地减少了明文值泄露的信息, 比如我们的每次获取I的明文值之前都将I中值大于k的值, 也就是我们此次delete中用不到的值隐藏掉. 每一方最终也会获取$core_\lambda(v)$为k的每个节点v, 所以算法只泄露了同样值为k的节点加入集合的前后顺序. 我们保证这样较好的安全性的开销主要是使用oblivious计算对加密数组I的值进行转化, 需要进行$|V_{remain}|$次计算, $|V_{remain}|$是未删除的顶点数量.

算法的复杂度: 

- 算法1每次删除单个节点$v$, 需要依次遍历完所有的顶点. 每次delete操作需要修改各层中节点$v$的邻居顶点的度, 时间复杂度约为$O(|L||V|^2)$
- 算法2每次删除多个节点, 总删除次数远小于顶点数量, 每次delete操作需要重新计算各层所有顶点的度, 时间复杂度约为$O(|L||\alpha|)$

### 5 实验

#### 5.1 实验设置

在本节中我们评估我们设计的三种安全算法, 并在几个不同的**真实数据集**下进行对比实验, 详细数据如表1所示. 另外我们还使用了不同顶点数和密度的**合成数据集**用来做对比实验. 我们用来实验的三种算法为:

1. 算法1: 按照Firmcore工作中的原始算法, 每次delete操作删除一个节点, 只更新其邻居节点的$I$值
2. 算法2: 每次delete操作批量删除节点, 更新全部节点的I值
3. 算法3: 算法1和算法2的综合, 根据临界条件删除单个或者多个节点

我们在实验中调整了各种参数, 包括我们在多台机器上进行实验, 每台机器放置1个或者几个计算方.

评价指标(metrics): 我们评估算法性能的指标为算法在指定数据集和参数时的平均运行时间, 即从各方连接成功到各方都获取到最终结果所需的时间.

实验环境: 我们在cpu为Intel 5218R×2的塔式服务器Dell-T640, _, _上进行分布式实验, 各方所在的机器之间通过局域网连接.

| 数据集    | 层数 | 顶点数 | 边数   | 边数/(顶点数 * 层数) |
| --------- | ---- | ------ | ------ | -------------------- |
| Homo      | 7    | 18222  | 153922 | 1.21                 |
| Sacchcere | 7    | 5658   | 247152 | 6.24                 |
| Sanremo   | 3    | 56562  | 317468 | 1.87                 |
| Slashdot  | 11   | 51083  | 139788 | 0.25                 |

#### 5.2 实验结果

> 绘画实验结果数据可视化图, 并且分析数据结果(好在哪里), 然后简要分析原因

第一组实验我们验收主要结果, 体现三种算法在4个不同数据集上的运行时间, 我们目的是为了证明改进后的算法2比算法1有着更高的效率, 并且在某些数据集中, 算法3相对算法2也有一些性能提升.

我们设置m=3, $\lambda$=2, 分别使用以上三种算法记录在不同数据集上的运行时间, 结果如图1所示. 算法1因为在顶点比较多的数据集上运行时间过长所以不统计其具体时长. 可以观察得出算法1的运行时间约为算法2的8倍, 算法2的运行时间约为1.1~1.2倍.可以看出, **节点越多**的图数据集, 算法2和算法3的提升的效果越好.

![image-20240729111326706](./assets/image-20240729111326706.png)

**impact of varying of m:** 我们从1开始逐渐增大m的值, 最大不会超过层数$l$, 设置$\lambda$始终为$\lceil{\frac{m}{2}}\rceil$, 观察三种算法在不同数据集的运行时间, 并在图1中展示. 可以观察得出, 随着m的增大, 算法在各个数据集上的时间

**impact of varying of λ:** 我们设置m为6, 改变松弛量$\lambda$从1到m, 观察三种算法在不同数据集的运行时间

改变图中顶点数量(合成图) - 时间变化

改变图的疏密程度(密度) - 时间变化

### 6 相关工作

> 使用到的前人已有的工作和技术

- 多层图上的稠密子图发现: 
- 安全多方计算: 
- oblivious算法: 

### 7 结论

在这篇论文中, 我们提出了MPC-Firmcore, 这是一种在隐私联邦多层图结构中计算稠密子图的高效且安全的算法, 我们基于原始Firmcore算法, 提出了三种不同的可以安全解决该该问题的算法, `算法1`将原始算法的数据加密计算, 尽可能同时地减少隐私泄露和使用明文计算. `算法2`在算法1基础上, 减少了迭代次数, 进一步提高了效率, `算法3`综合了`算法1`和`算法2`的优点, 使得算法在不同情况下采取更优的计算方法. 我们在多个真实和合成的数据集对算法进行了评估, 算法2和算法3比算法1的平均效率高约5倍和4倍. 我们提出了一种可以把隐私计算应用于多层图计算的新问题并给出了一种解决方式, 我们希望我们的算法能为多层图挖掘领域提供新的思路. 在未来我们还会考虑更多的多层图领域计算问题和隐私计算的综合.

### 8 参考文献

