### 安全的Firmcore算法

> 我们先使用networkx来模拟真实的图数据库

mpc在每一方运行相同的代码，但是输入时必须加密，防止其他方得知真实数据

多层图具有L层，，每层V个节点

开始时初始化图数据中每个节点的度（设置一个属性degree记录）

算法的第一个输入是每一层（每一方）的度列表（节点id -> 度）

得到的汇合输入为整个多层图的度矩阵`Degree`（L*V）

初始化数组`I`（v_id -> 每个节点在所有层中第λ大的度）

最终结果为数组`Core`，k-> firmcore为k的节点id集合

### 实现的各种方案

**安全的输入**

1. 开始时只输入**度矩阵**
2. 开始时输入能表示整个图的**邻接矩阵/邻接表**
   - 如果是邻接表, 输入时**每个节点的度**将会暴露(每个子数组的长度)


如何表示整个图的**邻接矩阵**:

> 主要问题: seclist元素不能是数组, 但是访问顶点时需要加密

   * 一个大list, 每层一个list, list中每个顶点有一个list, 格式为[该顶点id, 邻居id1, 邻居id2...]
   * 一个大list, 每层一个list, list中每个顶点有一个对象Node, Node中有一个属性next, 指向下一个邻居

**数据结构**

1. 只设置数组`I`
2. 同时设置数组`I`和`B` **不能实现! ** B中数据会直接暴露每个值为I[i]的节点数量

### 框架mpyc使用注意

- 直接运行mpc程序, 默认加参数`-M1, -I0`
- 安全类型是**不可哈希的**, 不可用作set元素, dict的key, 但可以作为list元素, 以及dict的value
- 安全类型是不能直接用于if语句的, 所以不能使用list的remove方法
- if_else(c, a, b)函数中a,b如果是数组, 只能是长度相同的数组, 可以是一个明文数a和一个加密数b, 但是返回的一定是加密数a或者b
- 在原论文的伪代码中使用数组`B`是不安全的, 因为即使B中的顶点节点是加密的, 但是B也暴露了每个度含有节点的个数
- 使用mpc.if_else函数的技巧1: 用数组的一个填充位放判断的另一种情况, 最后将该位去掉即可
- 不能使用and等**布尔运算**符号, 但可以使用&和|等**位运算**符
- 加密数可以直接和明文数字进行**计算**和**比较**
- 不能在M>1时使用try catch语句捕捉错误, 会直接导致异步程序终止
- 如果安全类型实在无法用密文实现, 那么也可以使用明文(有待以后再优化)
- sec_int中可以为None, 但是在进行任何计算中都会报错

#### seclist

- seclist是安全类型的列表, 他使用的索引可以是**明文**整数/数组, 也可以是**安全**整数/数组, 但是注意它不能用于mpc.sum求和, 需要先转为普通list, 取索引时也不能使用安全整数**截取**(不然岂不是就让别人知道这个数的大小了)
- 可以使用remove函数, 但是需要加上await关键字

几种重要的安全数组对比:

|          | list[secint]       | SecureArray                | seclist                   | np.array[secint] |
| -------- | ------------------ | -------------------------- | ------------------------- | ---------------- |
| 生成     | 列表中填充安全类型 | 使用mpc.fromlist(list)函数 | 使用seclist(list)构造函数 | np构造函数       |
| 索引     | 普通索引           | 普通索引                   | 安全索引                  | 普通索引         |
| 排序     | mpc.sorted         | mpc.np_sort, mpc.sorted    | seclist.sort              | mpc.sorted       |
| 元素类型 | 普通/安全类型      | 安全类型                   | 普通/安全数字             | 普通/安全数字    |

#### 使用的明文

- 每次获取的等于k的顶点id数组v_list的长度
- 每次从v_list获取的v_id(需要传到数据库中)

### **密文计算问题**

从一个密文数组ls中获取所有值为a的索引值

> 方法1

1. 记录数组is_a为ls中每个值是否是a, 是1, 否0
2. 计算ls_a中1的个数k
3. 设置数组ix为长为len(a)的数组, 最后一位为填充位
4. 遍历ls, 如果该位ls_a为1, 在ix的下一位填充ls的当前索引, 不然在最后一位填充当前索引
5. 最后获取ix的前k位(后面全为-1)

> 方法2

1. ls.count获取a的个数k
2. 不是k的均设置为-1
3. ls.sort()排序, 取后k位

### 其他改进想法

计算经验表示: mpc输入 ≈ mpc输出 > mpc计算 >> 普通计算

对于**输入数据**的考虑:

- 没有任何**初始输入**, 仅在mpc计算中需要哪个数据时, 每一方再提供给其他方该数据, 安全性最好, 但是需要很多次多方输入, 非常不现实

- 每层图输入其**每个节点的度列表**(在稠密子图计算中), 但时候在计算过程中还需要获取**某个节点的邻居**等信息, 该方法的安全性较好, 但是代价是大量的mpc多方输入, 效率较低
- 每层图输入其邻接表(adj_list), 安全性较差, 甚至有**违背安全多方计算的原则**, (原因是即使是加密后的邻接表, 也会暴露节点的度等信息), 效率较高
- 每层图输入其邻接矩阵(adj_mat), 安全性较好, 邻接矩阵不会暴露**除了节点数量**之外的其他信息, 虽然输入的数据结构开销大, 但是可以之后不再需要其他额外的信息, 且效率较高

实际上这些算法过程在实现时仍然存在一些数据泄露情况(一些与最终结果**无明显关系的中间结果**)

一些**算法细节**

- 在获取每个k对应的v_list时, 隐藏其个数, 例如不消去填充位的-1, 在后面对这些-1做特殊处理, 安全性更好 **但是如何处理这些-1?**
- 表示邻接表时, 使用每个一层每个节点表示为一个数组[自身id, 邻居1id, 邻居2id].
- 用**自定义的数据结构**SecureNode表示邻接表, 邻居节点表示为一个链表, 但是自定义的数据结构**不能用seclist安全类型的索引获取元素**
- 获取seclist安全数组中的自定义对象: 可以使用一个单元向量与其进行**点乘**, 获得指定位置的值
- 可以不对于每个k找出其所有顶点的list, 而是每次找出一个节点, 对于一个针对的k
- 由于在比较过程中也需要对每个顶点确定I是否变化, 不如不去找deg(v) == I[v] - 1的元素, 每次都将所有的I的更新一遍
- 更新I的时候, 只需要考虑那些还没被加入core的节点, 否则会在B中找不到元素

| SMPC的初始输入                                               | 算法实现难度 | 安全性                                   | 执行效率 |
| ------------------------------------------------------------ | ------------ | ---------------------------------------- | -------- |
| 无初始输入, 每次需要计算时获取                               | 很难         | 只有算法中的个别数据泄露                 | 很低     |
| 单层图每个节点的**度**                                       | 一般         | 只有算法中的个别数据泄露                 | 较低     |
| 单层图的**邻接表**                                           | 一般         | 不安全(违背了SMPC原则)                   | 较低     |
| 单层图的**邻接矩阵**                                         | 一般         | 只有算法中的个别数据泄露                 | 较低     |
| 单层图每个节点的**度**, Top-λ使用明文计算, <br />在每次更新**全部节点**的Top-λ | 容易         | 保护了原始节点的度, 和每次需要更新的节点 | 较高     |
| 单层图每个节点的**度**, Top-λ使用明文计算, <br />在每次更新部分节点的Top-λ | 容易         | 只保护了原始节点的度                     | 较高     |

### 其他加密工具

> 加密工具应该具有的特点: 封装性, 抽象性高, 不涉及密码学原理
>
> 实现了多方安全计算的框架效率较低, 原因是目前还没有把安全多方计算运用于图计算的实例

- MP-SPDZ: 原理和功能和mpyc很相似, 但是使用难度较大
- libscapi: C++实现, C++接口
- 隐语: 在MPC上实现的隐私计算api较少, 需要自己造轮子
- 不直接利用实现好的smpc框架, 而是使用smpc中常见的原语, 实现图计算所需要的算子, 如:
  1. 混淆电路
  2. 秘密共享
  3. 同态加密
- 利用差分隐私方法, 计算的结果会丢失准确性, 暂时没有考虑

### 遇到的bug

- 使用循环中的seclist.`index`和`remove`时, 在单方计算没问题, 但是在多方计算就出现bug, 有可能是**实际修改的同一个数据库, 出现了死锁**
- RuntimeError: Event loop stopped before Future completed.: 空数组使用count等函数报错, 数组长度是已知的, 可以直接判断